import numpy as np
import sympy as sp

import utilities.assembly_utilities as assembly_utilities
import utilities.K_func_generator as K_func_generator

# Base class used to generate the domain mapping
class Chi_Func:
    def __call__(self, eta, x3):
        return self.chi(eta, x3)
    
    def x3_derivative(self, eta, x3):
        return self.chi_x3(eta, x3)
    
    def eta_derivative(self, eta, x3):
        return self.chi_eta(eta, x3)

# Two cubic functions joined at x3=1 as a unique C^1 function
class Bezier_Chi(Chi_Func):
    def __init__(self, A):
        self.eta_var = sp.Symbol('eta', negative=False)
        self.x3_var  = sp.Symbol('x3',  negative=False)

        self.first_chi_expr  = self.eta_var * self.x3_var * (1 + (1-self.x3_var) * self.eta_var * self.x3_var / A)
        self.second_chi_expr = self.eta_var + (A-self.eta_var)/A*(self.x3_var-1) * ( self.eta_var + (self.x3_var-1) * ( 2*(A-self.eta_var) - (self.x3_var-1)*(A-self.eta_var) ) )

        self.chi = sp.lambdify( [self.eta_var, self.x3_var], 
                               sp.Piecewise(
                                   (self.first_chi_expr, self.x3_var <= 1),
                                   (self.second_chi_expr, True)
                               ), 'numpy' )

        self.chi_x3  = sp.lambdify( [self.eta_var, self.x3_var], 
                                   sp.Piecewise(
                                       (sp.diff(self.first_chi_expr,  self.x3_var), self.x3_var <= 1),
                                       (sp.diff(self.second_chi_expr, self.x3_var), True),
                                   ), 'numpy' )

        self.chi_eta = sp.lambdify( [self.eta_var, self.x3_var], 
                                   sp.Piecewise(
                                       (sp.diff(self.first_chi_expr,  self.eta_var), self.x3_var <= 1),
                                       (sp.diff(self.second_chi_expr, self.eta_var), True),
                                   ), 'numpy' )

# Two linear functions, ranging from (0,0) to (1,\eta) and from (1, \eta) to (2, A)
class Linear_Chi(Chi_Func):
    def __init__(self, A):
        self.eta_var = sp.Symbol('eta', negative=False)
        self.x3_var  = sp.Symbol('x3',  negative=False)

        self.first_chi_expr  = self.x3_var * self.eta_var
        self.second_chi_expr = self.eta_var + (A - self.eta_var) * (self.x3_var - 1)

        self.chi = sp.lambdify( [self.eta_var, self.x3_var], 
                               sp.Piecewise(
                                   (self.first_chi_expr, self.x3_var <= 1),
                                   (self.second_chi_expr, True)
                               ), 'numpy' )

        self.chi_x3  = sp.lambdify( [self.eta_var, self.x3_var], 
                                   sp.Piecewise(
                                       (sp.diff(self.first_chi_expr,  self.x3_var), self.x3_var <= 1),
                                       (sp.diff(self.second_chi_expr, self.x3_var), True),
                                   ), 'numpy' )

        self.chi_eta = sp.lambdify( [self.eta_var, self.x3_var], 
                                   sp.Piecewise(
                                       (sp.diff(self.first_chi_expr,  self.eta_var), self.x3_var <= 1),
                                       (sp.diff(self.second_chi_expr, self.eta_var), True),
                                   ), 'numpy' )
        
# Two linear functions, ranging from (0,0) to (1,\eta) and from (1, \eta) to (2, A)
class Richards_Chi(Chi_Func):
    def __init__(self, A):
        self.eta_var = sp.Symbol('eta', negative=False)
        self.x3_var  = sp.Symbol('x3',  negative=False)

        self.chi     = sp.lambdify([self.eta_var, self.x3_var], self.chi_expr)
        self.chi_x3  = sp.lambdify([self.eta_var, self.x3_var],  self.eta_var)
        self.chi_eta = sp.lambdify([self.eta_var, self.x3_var],   self.x3_var)


# Helper function to evaluate chi in (eta,x3) generated by assembly_utilities.compute_eta_x3. Used during the integration over a triangle
def chi_x3_eta_gen(chi: Chi_Func,
                   base_height: float, element_height: float, m: float, 
                   ls_eta: float, rs_eta: float, 
                   x: float, y: float):
    eta, x3 = assembly_utilities.compute_eta_x3(base_height, element_height, m, ls_eta, rs_eta, x, y)

    return chi.x3_derivative(eta, x3), chi.eta_derivative(eta, x3)


# Simple function that constructs the local K_func at (x,y) for integration over a triangle.
# The function assumes that K=I*coeff
def chi_quick_K_func_eval(chi: Chi_Func, 
                          base_height: float, element_height: float, 
                          m: int, ls_eta: float, rs_eta: float, grad_eta: float, 
                          coeff: float, x: float, y: float):
    chi_x3, chi_eta = chi_x3_eta_gen(chi, base_height, element_height, m, ls_eta, rs_eta, x, y)
    return K_func_generator.quick_K_func_eval(chi_x3, chi_eta, grad_eta, coeff)

# Simple function that constructs the local K_func at (x,y) for integration over a triangle
# The function assumes that the conductivity tensor is K*coeff
def chi_complete_K_func_eval(chi: Chi_Func, base_height: float, element_height: float, 
                             m: int, ls_eta: float, rs_eta: float, grad_eta: float, 
                             coeff: float, x: float, y: float):
    chi_x3, chi_eta = chi_x3_eta_gen(chi, base_height, element_height, m, ls_eta, rs_eta, x, y)
    return K_func_generator.complete_K_func_eval(chi_x3, chi_eta, grad_eta, coeff)